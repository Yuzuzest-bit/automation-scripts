#!/usr/bin/env bash
set -uo pipefail

# ------------------------------------------------------------
# zk_sync_due_from_parent_windows_fix.sh
# 親ノートの due: を子ノートに反映する (絵文字対応・頑丈版)
# ------------------------------------------------------------

# 文字コードを強制的にUTF-8に統一
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

PARENT_FILE="${1:-}"

if [[ -z "$PARENT_FILE" || ! -f "$PARENT_FILE" ]]; then
  echo "[ERR] Parent file not found: $PARENT_FILE"
  echo "Usage: $0 <dashboard_file> [search_root_dir]"
  exit 1
fi

# 検索ルートの設定
DEFAULT_ROOT="$(cd "$(dirname "$PARENT_FILE")/.." && pwd)"
SEARCH_ROOT="${2:-$DEFAULT_ROOT}"

if [[ ! -d "$SEARCH_ROOT" ]]; then
  echo "[ERR] Search directory not found: $SEARCH_ROOT"
  exit 1
fi

echo "[INFO] Indexing files in: $SEARCH_ROOT ..."

# --- 1. 高速化のためのファイルマッピング ---
declare -A FILE_MAP
while IFS= read -r FILE_PATH; do
  BASENAME=$(basename "$FILE_PATH" .md)
  FILE_MAP["$BASENAME"]="$FILE_PATH"
done < <(find "$SEARCH_ROOT" -name "*.md")

echo "[INFO] Indexing complete. Syncing due dates..."

# --- 2. 親ノートから更新対象行を抽出してループ ---
# grep -a : 絵文字が含まれていてもバイナリ扱いせずにテキストとして読む
# grep -E : 正規表現を使用
# パターン : [[...]] があり、かつ due: YYYY-MM-DD がある行
count=0

while IFS= read -r LINE; do
  # Windows改行コード除去
  LINE=$(echo "$LINE" | tr -d '\r')

  # --- 3. データ抽出 (アイコン等の干渉を避けるため個別に抽出) ---
  LINK=""
  DUE_DATE=""

  # リンク抽出: 最初の [[...]] の中身をとる
  if [[ "$LINE" =~ \[\[([^]]+)\]\] ]]; then
    LINK="${BASH_REMATCH[1]}"
  fi

  # 日付抽出: due: の後ろにある YYYY-MM-DD をとる
  # (アイコンが間に挟まっても、due: の直後さえ正しければOK)
  if [[ "$LINE" =~ due:[[:space:]]*([0-9]{4}-[0-9]{2}-[0-9]{2}) ]]; then
    DUE_DATE="${BASH_REMATCH[1]}"
  fi

  # 抽出失敗ならスキップ
  if [[ -z "$LINK" || -z "$DUE_DATE" ]]; then
    continue
  fi

  # --- 4. ファイル特定と更新 ---
  FILE_PATH="${FILE_MAP[$LINK]:-}"

  if [[ -z "$FILE_PATH" ]]; then
    # デバッグ用に、見つからない場合のみ表示（うるさければコメントアウト）
    # echo "[SKIP] File not found for link: [[$LINK]]"
    continue
  fi

  # awk で Frontmatter を安全に書き換え
  TMP_FILE=$(mktemp)
  awk -v due_val="due: $DUE_DATE" '
    BEGIN { inFM=0; fmDone=0; dueSet=0 }
    /^---$/ && inFM==0 && fmDone==0 { inFM=1; print; next }
    inFM==1 {
      if ($0 ~ /^due:[[:space:]]*/) {
        print due_val; dueSet=1; next
      }
      if ($0 ~ /^---$/) {
        if (dueSet==0) print due_val
        inFM=0; fmDone=1; print; next
      }
    }
    { print }
  ' "$FILE_PATH" > "$TMP_FILE"

  mv "$TMP_FILE" "$FILE_PATH"
  echo "[SYNCED] $LINK -> $DUE_DATE"
  count=$((count + 1))

# パイプの元: grep -a で強制テキスト扱い
done < <(grep -a -E '\[\[.+\]\].*due:[[:space:]]*[0-9]{4}-[0-9]{2}-[0-9]{2}' "$PARENT_FILE")

echo "----------------------------------------"
if [[ $count -eq 0 ]]; then
  echo "[WARN] 更新対象が見つかりませんでした。grepが空振りしている可能性があります。"
  echo "       対象ファイル: $PARENT_FILE"
else
  echo "完了！ $count 件のノートに期限を反映しました。"
fi
